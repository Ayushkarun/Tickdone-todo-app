Launching lib\main.dart on SM A528B in debug mode...
e: Daemon compilation failed: Could not connect to Kotlin compile daemon
java.lang.RuntimeException: Could not connect to Kotlin compile daemon
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemon(GradleKotlinCompilerWork.kt:204)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemonOrFallbackImpl(GradleKotlinCompilerWork.kt:161)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.run(GradleKotlinCompilerWork.kt:132)
	at org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction.execute(GradleCompilerRunnerWithWorkers.kt:76)
	at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:63)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:66)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:62)
	at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:100)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.lambda$execute$0(NoIsolationWorkerFactory.java:62)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:44)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:41)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:209)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)
	at org.gradle.workers.internal.AbstractWorker.executeWrappedInBuildOperation(AbstractWorker.java:41)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.execute(NoIsolationWorkerFactory.java:59)
	at org.gradle.workers.internal.DefaultWorkerExecutor.lambda$submitWork$0(DefaultWorkerExecutor.java:174)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runExecution(DefaultConditionalExecutionQueue.java:194)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.access$700(DefaultConditionalExecutionQueue.java:127)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner$1.run(DefaultConditionalExecutionQueue.java:169)
	at org.gradle.internal.Factories$1.create(Factories.java:31)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:263)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:127)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:132)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runBatch(DefaultConditionalExecutionQueue.java:164)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.run(DefaultConditionalExecutionQueue.java:133)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:48)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.base/java.lang.Thread.run(Unknown Source)

Errors were stored into D:\Mak big\Mini project\TickDone\tickdone\android\.gradle\kotlin\errors\errors-1757921860073.log
√ Built build\app\outputs\flutter-apk\app-debug.apk
I/flutter (21615): [IMPORTANT:flutter/shell/platform/android/android_context_vk_impeller.cc(60)] Using the Impeller rendering backend (Vulkan).

======================================================================================

Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
warning: [options] source value 8 is obsolete and will be removed in a future release
warning: [options] target value 8 is obsolete and will be removed in a future release
warning: [options] To suppress warnings about obsolete options, use -Xlint:-options.
3 warnings
e: Daemon compilation failed: Could not connect to Kotlin compile daemon
java.lang.RuntimeException: Could not connect to Kotlin compile daemon
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemon(GradleKotlinCompilerWork.kt:204)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemonOrFallbackImpl(GradleKotlinCompilerWork.kt:161)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.run(GradleKotlinCompilerWork.kt:132)
	at org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction.execute(GradleCompilerRunnerWithWorkers.kt:76)
	at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:63)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:66)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:62)
	at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:100)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.lambda$execute$0(NoIsolationWorkerFactory.java:62)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:44)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:41)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:209)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)
	at org.gradle.workers.internal.AbstractWorker.executeWrappedInBuildOperation(AbstractWorker.java:41)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.execute(NoIsolationWorkerFactory.java:59)
	at org.gradle.workers.internal.DefaultWorkerExecutor.lambda$submitWork$0(DefaultWorkerExecutor.java:174)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runExecution(DefaultConditionalExecutionQueue.java:194)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.access$700(DefaultConditionalExecutionQueue.java:127)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner$1.run(DefaultConditionalExecutionQueue.java:169)
	at org.gradle.internal.Factories$1.create(Factories.java:31)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:263)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:127)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:132)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runBatch(DefaultConditionalExecutionQueue.java:164)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.run(DefaultConditionalExecutionQueue.java:133)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:48)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.base/java.lang.Thread.run(Unknown Source)

exception: c:\Users\HP\AppData\Local\Pub\Cache\hosted\pub.dev\shared_preferences_android-2.4.10\android\src\main\kotlin\io\flutter\plugins\sharedpreferences\SharedPreferencesPlugin.kt:451:52: warning: unnecessary non-null assertion (!!) on a non-null receiver of type String
exception:       if (value!!.startsWith(LIST_PREFIX) && !value!!.startsWith(JSON_LIST_PREFIX)) {
exception:            

========================================================

Got you, Ayush! Let’s unpack that whole :runQuery thing slowly, step by step, with a tiny real example and why each part exists.

What you’re doing in one line

You send one POST request to Firestore’s :runQuery endpoint.
Inside the request body, you describe what to search (collection + filters).
Firestore replies with the matching documents.

You are not inserting anything; you’re asking Firestore to run a search.

The full journey (simple story)

You prepare inputs

formattedDate → e.g., "2025-08-30"

userUid → e.g., "abc123"

You build the URL

final url = Uri.parse(
  '${Apiservice.firestoreBaseUrl}:runQuery?key=${Apiservice.apiKey}'
);


firestoreBaseUrl looks like
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents

:runQuery means “please run the query I’ll send in the body.”

apiKey authenticates your request (kept on server side ideally).

Why used? Firestore needs the API key and the special :runQuery path to accept complex queries.

You build the request body (the actual query)
Here’s your Dart map annotated:

final singleDayQueryBody = {
  "structuredQuery": { // Tell Firestore we’re sending a structured (typed) query
    "from": [
      {"collectionId": "tasks"} // Look inside the 'tasks' collection
    ],
    "where": { // Apply filters (conditions)
      "compositeFilter": { // Multiple filters combined together
        "op": "AND",       // Join filters with AND (both must be true)
        "filters": [
          { // Filter #1
            "fieldFilter": {
              "field": {"fieldPath": "date"},     // Which field?
              "op": "EQUAL",                      // Comparison operator
              "value": {"stringValue": formattedDate} // The value (typed!)
            }
          },
          { // Filter #2
            "fieldFilter": {
              "field": {"fieldPath": "userId"},   // Which field?
              "op": "EQUAL",                      // Comparison operator
              "value": {"stringValue": userUid}   // The value (typed!)
            }
          }
        ]
      }
    }
  }
};


Why each part is used?

structuredQuery → Firestore’s format for describing searches.

from.collectionId → tells which collection to search (tasks).

where.compositeFilter → lets you combine multiple conditions.

op: "AND" → require both conditions to match.

filters[] → the list of conditions.

fieldFilter.field.fieldPath → which field in your doc (e.g., date).

fieldFilter.op: "EQUAL" → match exact value.

value.stringValue → Firestore requires typed values; here the field is a string. (Other examples: integerValue, booleanValue, timestampValue.)

👉 Important: Your app must match the field types you stored in Firestore.
If date was stored as a string ("2025-08-30"), query it as stringValue.
If it was a timestamp, you’d need timestampValue and a different format.

You send the HTTP request

await http.post(
  url,
  headers: {"Content-Type": "application/json"},
  body: json.encode(singleDayQueryBody),
);


Why used?

POST is required because you’re sending a query description in the body.

application/json tells the server you’re sending JSON.

Firestore runs your query and replies
The response is an array; each item looks like:

{
  "document": {
    "name": "projects/PROJ/databases/(default)/documents/tasks/abcd1234",
    "fields": {
      "title": {"stringValue": "Buy Groceries"},
      "description": {"stringValue": "Milk and Eggs"},
      "category": {"stringValue": "shopping"},
      "date": {"stringValue": "2025-08-30"},
      "time": {"stringValue": "10:00 AM"},
      "userId": {"stringValue": "abc123"}
    },
    "createTime": "2025-08-28T10:30:15.123456Z",
    "updateTime": "2025-08-28T10:30:15.123456Z"
  },
  "readTime": "2025-08-28T10:30:15.123456Z"
}


Why shaped like this?

Firestore always returns the document path in name.

Your actual data is in fields, with typed values.

Times are metadata; you usually don’t show them.

You parse it into your app’s list

final List data = json.decode(response.body);
task.clear();

for (var item in data) {
  if (item.containsKey('document')) {
    final doc = item['document'];
    final taskId = doc['name'].split('/').last;   // "abcd1234"
    task.add({'id': taskId, 'fields': doc['fields']});
  }
}


Why used?

You need a clean list like [{id: "...", fields: {...}}, ...] to show in UI.

split('/').last extracts the actual document ID.

You show it on screen

If still fetching → show spinner.

If empty → show “no tasks”.

Else → build ListView cards using fields['title']['stringValue'], etc.

Tiny real example (with filled values)
What you send (body)
{
  "structuredQuery": {
    "from": [{"collectionId": "tasks"}],
    "where": {
      "compositeFilter": {
        "op": "AND",
        "filters": [
          {
            "fieldFilter": {
              "field": {"fieldPath": "date"},
              "op": "EQUAL",
              "value": {"stringValue": "2025-08-30"}
            }
          },
          {
            "fieldFilter": {
              "field": {"fieldPath": "userId"},
              "op": "EQUAL",
              "value": {"stringValue": "abc123"}
            }
          }
        ]
      }
    }
  }
}

Why this works

You asked: “Find tasks for this user on this date.”

Firestore understands it because you used its structuredQuery format with typed values.

Quick “when to use what”

GET → when you know the exact document path (e.g., /tasks/abcd1234).

POST :runQuery → when you need to search with filters (date, userId, etc.).

Common pitfalls (so you don’t get stuck)

❌ date stored as timestamp but queried as stringValue.
✅ Either store as string consistently, or query as timestampValue.

❌ Wrong date format (dd-MM-yyyy).
✅ Use the same format you saved (you’re using "yyyy-MM-dd").

❌ Missing header Content-Type: application/json.
✅ Always include it.

❌ userUid is null (not saved in SharedPreferences yet).
✅ Ensure you set it after login.

If you want, I can rewrite your fetchTasksFromFirebase with extra comments inline (so future-you immediately knows what each line does).



  Future<void> _showTimePickerAndScheduleNotification() async {
    // Show a time picker for the user to select a time
    final selectedTime = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.now(), // The clock will start at the current time
    );

    // If the user didn't cancel the time picker
    if (selectedTime != null) {
      // Get the current date and combine it with the selected time
      final now = DateTime.now();
      final scheduledDateTime = DateTime(
        now.year,
        now.month,
        now.day,
        selectedTime.hour,
        selectedTime.minute,
      );

      // Now, we check if the selected time is in the future.
      // If it's in the past, it won't work, so we need to add a day.
      final finalScheduledTime = scheduledDateTime.isAfter(now)
          ? scheduledDateTime
          : scheduledDateTime.add(const Duration(days: 1));

      // Finally, call the new method from your NotificationService
      NotificationService().scheduleNotificationAtTime(
        id: 1, // You can use a unique ID for each notification
        title: 'Task Reminder',
        body: 'Your task is due now!',
        scheduledTime: finalScheduledTime,
      );

      // Show a message to the user so they know it worked
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          elevation: 0,
          behavior: SnackBarBehavior.floating,
          backgroundColor: Colors.transparent,
          content: AwesomeSnackbarContent(
            title: 'Success!',
            message: 'Notification scheduled for ${finalScheduledTime.toString().split('.')[0]}',
            contentType: ContentType.success,
          ),
        ),
      );
    }
  }


     onTap: () async {
                await Navigator.push(
                  context,
                  PageRouteBuilder(
                    pageBuilder:
                        (context, animation, secondaryAnimation) =>
                            const Progressscreen(),
                    transitionsBuilder: (
                      context,
                      animation,
                      secondaryAnimation,
                      child,
                    ) {
                      return FadeTransition(opacity: animation, child: child);
                    },
                  ),
                );
              },



              // In NewTask.dart
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:day_night_time_picker/day_night_time_picker.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:tickdone/Services/Provider/date_provider.dart';
import 'package:tickdone/Services/Provider/task_provider.dart';
import 'package:tickdone/Services/Task/Newtaskservice.dart';
import 'package:intl/intl.dart';
import 'package:tickdone/Services/Notification/notification_service.dart';

class Newtask extends StatefulWidget {
  const Newtask({super.key});

  @override
  State<Newtask> createState() => _NewtaskState();
}

class _NewtaskState extends State<Newtask> {
  final taskkey = GlobalKey<FormState>();

  final TextEditingController titlecontroller = TextEditingController();
  final TextEditingController descriptioncontroller = TextEditingController();

  // A variable to hold the selected date for a single-day task.
  DateTime? selectedDate;
  // A variable to hold the selected time. It starts as null.
  Time? selectedTime;
  // A list of booleans to track which toggle button is selected.
  // We'll keep only 'Single Day' active.
  List<bool> isSelected = [true];

  // A list of pre-defined categories.
  final List<String> category = [
    'Work',
    'Personal',
    'Shopping',
    'Health',
    'Skill',
    'Home',
  ];
  // A single string to hold the selected category.
  String? selectedCategory;

  // Simple function to format a DateTime object into "day-month-year".
  String formatDate(DateTime date) {
    return "${date.day}-${date.month}-${date.year}";
  }

  // Simple function to format a Time object into 12-hour format with AM/PM.
  String formatTime(Time time) {
    final hour = time.hourOfPeriod == 0 ? 12 : time.hourOfPeriod;
    final period = time.period == DayPeriod.am ? "AM" : "PM";
    return "$hour:${time.minute.toString().padLeft(2, '0')} $period";
  }

  // A helper function to check if the selected date is today.
  bool get isToday {
    if (selectedDate == null) {
      return false;
    }
    final now = DateTime.now();
    return selectedDate!.year == now.year &&
        selectedDate!.month == now.month &&
        selectedDate!.day == now.day;
  }

  void scheduleTaskNotification(String title, DateTime scheduledDateTime) {
    NotificationService().scheduleNotificationAtTime(
      id: title.hashCode, // A simple unique ID for the task
      title: 'Task Reminder:$title ',
      body: 'Lets Do it !!',
      scheduledTime: scheduledDateTime,
    );
  }

  // Shows the single date picker pop-up.
  void presentDatePicker() {
    showDatePicker(
      context: context,
      initialDate: selectedDate ?? DateTime.now(),
      firstDate: DateTime.now(),
      lastDate: DateTime(2030),
    ).then((pickedDate) {
      if (pickedDate == null) return;

      setState(() {
        selectedDate = pickedDate;
      });
    });
  }

  late final double padding = 15.w;
  late final double titleIconSize = 28.sp;
  late final double buttonHeight = 50.h;
  late final double buttonWidth = 0.80.sw;
  late final double textFieldVerticalSpace = 10.h;
  late final double verticalPadding = 12.h;
  late final double horizontalPadding = 20.w;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          onPressed: () {
            Navigator.pop(context);
          },
          icon: Icon(Icons.close, color: Colors.white, size: titleIconSize),
        ),
        backgroundColor: const Color(0xFF1C0E6F),
        title: Text(
          'Add Task',
          style: TextStyle(
            color: Colors.white,
            fontFamily: 'Poppins',
            fontSize: 20.sp,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
      backgroundColor: Colors.black,
      body: SafeArea(
        child: SingleChildScrollView(
          child: Form(
            key: taskkey,
            child: Padding(
              padding: EdgeInsets.all(padding),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Center(
                    child: ElevatedButton.icon(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF1C0E6F),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.only(
                            topLeft: Radius.circular(25.r),
                            bottomRight: Radius.circular(25.r),
                          ),
                        ),

                        padding: EdgeInsets.symmetric(
                          horizontal: 16.w,
                          vertical: 12.h,
                        ),
                      ),
                      onPressed: presentDatePicker,
                      icon: Icon(Icons.calendar_today, color: Colors.white),
                      label: Text(
                        'Select Date',
                        style: TextStyle(
                          color: Colors.white,
                          fontFamily: 'Poppins',
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                  SizedBox(height: 15.h),
                  TextFormField(
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please Enter Title';
                      }
                      return null;
                    },
                    controller: titlecontroller,
                    style: TextStyle(color: Colors.white),
                    decoration: InputDecoration(
                      labelText: "Title",
                      icon: const Icon(Icons.title_rounded),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12.r),
                      ),
                    ),
                  ),
                  SizedBox(height: 10.h),
                  TextFormField(
                    controller: descriptioncontroller,
                    style: TextStyle(color: Colors.white),
                    maxLines: 3,
                    decoration: InputDecoration(
                      labelText: "Description",
                      icon: const Icon(Icons.description),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12.r),
                      ),
                    ),
                  ),
                  SizedBox(height: textFieldVerticalSpace),
                  Text(
                    'Select Category',
                    style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w900,
                      fontSize: 15.sp,
                      fontFamily: 'Poppins',
                    ),
                  ),
                  SizedBox(height: 5.h),
                  Wrap(
                    spacing: 8.w,
                    runSpacing: 6.h,
                    children: List.generate(category.length, (index) {
                      final String current = category[index];
                      final bool isSelected = selectedCategory == current;

                      return ChoiceChip(
                        label: Text(current),
                        selected: isSelected,
                        selectedColor: const Color(0xFF1C0E6F),
                        backgroundColor: Colors.black87,
                        labelStyle: TextStyle(
                          color: Colors.white,
                          fontFamily: 'Poppins',
                        ),
                        onSelected: (bool value) {
                          setState(() {
                            if (value) {
                              selectedCategory = current;
                            } else {
                              selectedCategory = null;
                            }
                          });
                        },
                      );
                    }),
                  ),
                  SizedBox(height: textFieldVerticalSpace),
                  if (selectedDate != null)
                    Center(
                      child: Text(
                        "Selected Date: ${formatDate(selectedDate!)}",
                        style: const TextStyle(
                          fontFamily: 'Poppins',
                          color: Colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),

                  SizedBox(height: textFieldVerticalSpace),
                  ElevatedButton.icon(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF1C0E6F),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12.r),
                      ),
                      padding: EdgeInsets.symmetric(
                        vertical: verticalPadding,
                        horizontal: horizontalPadding,
                      ),
                    ),
                    onPressed: () {
                      FocusManager.instance.primaryFocus?.unfocus();
                      Navigator.of(context).push(
                        showPicker(
                          context: context,
                          value:
                              selectedTime ??
                              Time(
                                hour: DateTime.now().hour,
                                minute: DateTime.now().minute,
                              ),
                          onChange: (newTime) {
                            setState(() {
                              selectedTime = newTime;
                            });
                          },
                          iosStylePicker: true,
                          is24HrFormat: false,
                        ),
                      );
                    },
                    icon: const Icon(Icons.access_time, color: Colors.white),
                    label: Text(
                      "Pick Time (Optional)",
                      style: TextStyle(
                        fontFamily: 'Poppins',
                        fontWeight: FontWeight.bold,
                        fontSize: 15.sp,
                        color: Colors.white,
                      ),
                    ),
                  ),

                  // Show selected time ONLY after the user has picked it.
                  if (selectedTime != null)
                    Padding(
                      padding: EdgeInsets.only(top: 8.h),
                      child: Center(
                        child: Text(
                          "Selected Time: ${formatTime(selectedTime!)}",
                          style: const TextStyle(
                            fontFamily: 'Poppins',
                            fontSize: 14,
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),

                  SizedBox(height: 20.h),

                  Center(
                    child: SizedBox(
                      height: buttonHeight,
                      width: buttonWidth,
                      child: ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF1C0E6F),
                        ),
                        onPressed: () async {
                          final prefs = await SharedPreferences.getInstance();
                          final userUid = prefs.getString('userUID');
                          // 1. Check if the form is valid.
                          if (userUid != null) {
                            if (taskkey.currentState?.validate() ?? false) {
                              // 2. If the form is valid, then proceed with creating and saving the task.
                              final taskData = {
                                'title': {'stringValue': titlecontroller.text},
                                'description': {
                                  'stringValue': descriptioncontroller.text,
                                },
                                'category': {
                                  'stringValue': selectedCategory ?? '',
                                },
                                'time': {
                                  'stringValue':
                                      selectedTime != null
                                          ? selectedTime!.format(context)
                                          : '',
                                },
                                'userId': {'stringValue': userUid},
                              };

                              // 3. Conditionally add a single date based on user selection.
                              if (selectedDate != null) {
                                taskData['date'] = {
                                  'stringValue': DateFormat(
                                    'yyyy-MM-dd',
                                  ).format(selectedDate!),
                                };
                              }

                              // 4. Call the service to save the task.
                              final taskService = Addnewtaskservice();
                              await taskService.addtasktofirebase(
                                taskData,
                                context,
                                userUid,
                              );
                              // Get the TaskProvider instance
                              final taskProvider = Provider.of<TaskProvider>(
                                context,
                                listen: false,
                              );

                              // Get the DateProvider to know which date's tasks to refresh
                              final dateProvider = Provider.of<DateProvider>(
                                context,
                                listen: false,
                              );
                              if (selectedDate != null &&
                                  selectedTime != null) {
                                final now = DateTime.now();
                                final scheduledDateTime = DateTime(
                                  selectedDate!.year,
                                  selectedDate!.month,
                                  selectedDate!.day,
                                  selectedTime!.hour,
                                  selectedTime!.minute,
                                );

                                // Check if the scheduled time is in the past and adjust it if needed.
                                final finalScheduledTime =
                                    scheduledDateTime.isAfter(now)
                                        ? scheduledDateTime
                                        : scheduledDateTime.add(
                                          const Duration(days: 1),
                                        );

                                // Call the new method to schedule the notification.
                                scheduleTaskNotification(
                                  titlecontroller.text,
                                  finalScheduledTime,
                                );
                              }
                              await taskProvider.fetchTasksFromFirebase(
                                dateProvider.selectedDate,
                              );
                              Navigator.pop(context);
                            }
                          }
                        },
                        child: Text(
                          'Save Task',
                          style: TextStyle(
                            color: Colors.white,
                            fontFamily: 'Poppins',
                            fontWeight: FontWeight.bold,
                            fontSize: 15.sp,
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
