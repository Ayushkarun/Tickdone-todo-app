Got you, Ayush! Let‚Äôs unpack that whole :runQuery thing slowly, step by step, with a tiny real example and why each part exists.

What you‚Äôre doing in one line

You send one POST request to Firestore‚Äôs :runQuery endpoint.
Inside the request body, you describe what to search (collection + filters).
Firestore replies with the matching documents.

You are not inserting anything; you‚Äôre asking Firestore to run a search.

The full journey (simple story)

You prepare inputs

formattedDate ‚Üí e.g., "2025-08-30"

userUid ‚Üí e.g., "abc123"

You build the URL

final url = Uri.parse(
  '${Apiservice.firestoreBaseUrl}:runQuery?key=${Apiservice.apiKey}'
);


firestoreBaseUrl looks like
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents

:runQuery means ‚Äúplease run the query I‚Äôll send in the body.‚Äù

apiKey authenticates your request (kept on server side ideally).

Why used? Firestore needs the API key and the special :runQuery path to accept complex queries.

You build the request body (the actual query)
Here‚Äôs your Dart map annotated:

final singleDayQueryBody = {
  "structuredQuery": { // Tell Firestore we‚Äôre sending a structured (typed) query
    "from": [
      {"collectionId": "tasks"} // Look inside the 'tasks' collection
    ],
    "where": { // Apply filters (conditions)
      "compositeFilter": { // Multiple filters combined together
        "op": "AND",       // Join filters with AND (both must be true)
        "filters": [
          { // Filter #1
            "fieldFilter": {
              "field": {"fieldPath": "date"},     // Which field?
              "op": "EQUAL",                      // Comparison operator
              "value": {"stringValue": formattedDate} // The value (typed!)
            }
          },
          { // Filter #2
            "fieldFilter": {
              "field": {"fieldPath": "userId"},   // Which field?
              "op": "EQUAL",                      // Comparison operator
              "value": {"stringValue": userUid}   // The value (typed!)
            }
          }
        ]
      }
    }
  }
};


Why each part is used?

structuredQuery ‚Üí Firestore‚Äôs format for describing searches.

from.collectionId ‚Üí tells which collection to search (tasks).

where.compositeFilter ‚Üí lets you combine multiple conditions.

op: "AND" ‚Üí require both conditions to match.

filters[] ‚Üí the list of conditions.

fieldFilter.field.fieldPath ‚Üí which field in your doc (e.g., date).

fieldFilter.op: "EQUAL" ‚Üí match exact value.

value.stringValue ‚Üí Firestore requires typed values; here the field is a string. (Other examples: integerValue, booleanValue, timestampValue.)

üëâ Important: Your app must match the field types you stored in Firestore.
If date was stored as a string ("2025-08-30"), query it as stringValue.
If it was a timestamp, you‚Äôd need timestampValue and a different format.

You send the HTTP request

await http.post(
  url,
  headers: {"Content-Type": "application/json"},
  body: json.encode(singleDayQueryBody),
);


Why used?

POST is required because you‚Äôre sending a query description in the body.

application/json tells the server you‚Äôre sending JSON.

Firestore runs your query and replies
The response is an array; each item looks like:

{
  "document": {
    "name": "projects/PROJ/databases/(default)/documents/tasks/abcd1234",
    "fields": {
      "title": {"stringValue": "Buy Groceries"},
      "description": {"stringValue": "Milk and Eggs"},
      "category": {"stringValue": "shopping"},
      "date": {"stringValue": "2025-08-30"},
      "time": {"stringValue": "10:00 AM"},
      "userId": {"stringValue": "abc123"}
    },
    "createTime": "2025-08-28T10:30:15.123456Z",
    "updateTime": "2025-08-28T10:30:15.123456Z"
  },
  "readTime": "2025-08-28T10:30:15.123456Z"
}


Why shaped like this?

Firestore always returns the document path in name.

Your actual data is in fields, with typed values.

Times are metadata; you usually don‚Äôt show them.

You parse it into your app‚Äôs list

final List data = json.decode(response.body);
task.clear();

for (var item in data) {
  if (item.containsKey('document')) {
    final doc = item['document'];
    final taskId = doc['name'].split('/').last;   // "abcd1234"
    task.add({'id': taskId, 'fields': doc['fields']});
  }
}


Why used?

You need a clean list like [{id: "...", fields: {...}}, ...] to show in UI.

split('/').last extracts the actual document ID.

You show it on screen

If still fetching ‚Üí show spinner.

If empty ‚Üí show ‚Äúno tasks‚Äù.

Else ‚Üí build ListView cards using fields['title']['stringValue'], etc.

Tiny real example (with filled values)
What you send (body)
{
  "structuredQuery": {
    "from": [{"collectionId": "tasks"}],
    "where": {
      "compositeFilter": {
        "op": "AND",
        "filters": [
          {
            "fieldFilter": {
              "field": {"fieldPath": "date"},
              "op": "EQUAL",
              "value": {"stringValue": "2025-08-30"}
            }
          },
          {
            "fieldFilter": {
              "field": {"fieldPath": "userId"},
              "op": "EQUAL",
              "value": {"stringValue": "abc123"}
            }
          }
        ]
      }
    }
  }
}

Why this works

You asked: ‚ÄúFind tasks for this user on this date.‚Äù

Firestore understands it because you used its structuredQuery format with typed values.

Quick ‚Äúwhen to use what‚Äù

GET ‚Üí when you know the exact document path (e.g., /tasks/abcd1234).

POST :runQuery ‚Üí when you need to search with filters (date, userId, etc.).

Common pitfalls (so you don‚Äôt get stuck)

‚ùå date stored as timestamp but queried as stringValue.
‚úÖ Either store as string consistently, or query as timestampValue.

‚ùå Wrong date format (dd-MM-yyyy).
‚úÖ Use the same format you saved (you‚Äôre using "yyyy-MM-dd").

‚ùå Missing header Content-Type: application/json.
‚úÖ Always include it.

‚ùå userUid is null (not saved in SharedPreferences yet).
‚úÖ Ensure you set it after login.

If you want, I can rewrite your fetchTasksFromFirebase with extra comments inline (so future-you immediately knows what each line does).