Launching lib\main.dart on SM A528B in debug mode...
e: Daemon compilation failed: Could not connect to Kotlin compile daemon
java.lang.RuntimeException: Could not connect to Kotlin compile daemon
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemon(GradleKotlinCompilerWork.kt:204)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemonOrFallbackImpl(GradleKotlinCompilerWork.kt:161)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.run(GradleKotlinCompilerWork.kt:132)
	at org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction.execute(GradleCompilerRunnerWithWorkers.kt:76)
	at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:63)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:66)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:62)
	at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:100)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.lambda$execute$0(NoIsolationWorkerFactory.java:62)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:44)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:41)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:209)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)
	at org.gradle.workers.internal.AbstractWorker.executeWrappedInBuildOperation(AbstractWorker.java:41)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.execute(NoIsolationWorkerFactory.java:59)
	at org.gradle.workers.internal.DefaultWorkerExecutor.lambda$submitWork$0(DefaultWorkerExecutor.java:174)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runExecution(DefaultConditionalExecutionQueue.java:194)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.access$700(DefaultConditionalExecutionQueue.java:127)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner$1.run(DefaultConditionalExecutionQueue.java:169)
	at org.gradle.internal.Factories$1.create(Factories.java:31)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:263)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:127)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:132)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runBatch(DefaultConditionalExecutionQueue.java:164)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.run(DefaultConditionalExecutionQueue.java:133)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:48)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.base/java.lang.Thread.run(Unknown Source)

Errors were stored into D:\Mak big\Mini project\TickDone\tickdone\android\.gradle\kotlin\errors\errors-1757921860073.log
‚àö Built build\app\outputs\flutter-apk\app-debug.apk
I/flutter (21615): [IMPORTANT:flutter/shell/platform/android/android_context_vk_impeller.cc(60)] Using the Impeller rendering backend (Vulkan).

======================================================================================

Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
warning: [options] source value 8 is obsolete and will be removed in a future release
warning: [options] target value 8 is obsolete and will be removed in a future release
warning: [options] To suppress warnings about obsolete options, use -Xlint:-options.
3 warnings
e: Daemon compilation failed: Could not connect to Kotlin compile daemon
java.lang.RuntimeException: Could not connect to Kotlin compile daemon
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemon(GradleKotlinCompilerWork.kt:204)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemonOrFallbackImpl(GradleKotlinCompilerWork.kt:161)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.run(GradleKotlinCompilerWork.kt:132)
	at org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction.execute(GradleCompilerRunnerWithWorkers.kt:76)
	at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:63)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:66)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:62)
	at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:100)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.lambda$execute$0(NoIsolationWorkerFactory.java:62)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:44)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:41)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:209)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)
	at org.gradle.workers.internal.AbstractWorker.executeWrappedInBuildOperation(AbstractWorker.java:41)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.execute(NoIsolationWorkerFactory.java:59)
	at org.gradle.workers.internal.DefaultWorkerExecutor.lambda$submitWork$0(DefaultWorkerExecutor.java:174)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runExecution(DefaultConditionalExecutionQueue.java:194)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.access$700(DefaultConditionalExecutionQueue.java:127)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner$1.run(DefaultConditionalExecutionQueue.java:169)
	at org.gradle.internal.Factories$1.create(Factories.java:31)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:263)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:127)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:132)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runBatch(DefaultConditionalExecutionQueue.java:164)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.run(DefaultConditionalExecutionQueue.java:133)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:48)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.base/java.lang.Thread.run(Unknown Source)

exception: c:\Users\HP\AppData\Local\Pub\Cache\hosted\pub.dev\shared_preferences_android-2.4.10\android\src\main\kotlin\io\flutter\plugins\sharedpreferences\SharedPreferencesPlugin.kt:451:52: warning: unnecessary non-null assertion (!!) on a non-null receiver of type String
exception:       if (value!!.startsWith(LIST_PREFIX) && !value!!.startsWith(JSON_LIST_PREFIX)) {
exception:            

========================================================

Got you, Ayush! Let‚Äôs unpack that whole :runQuery thing slowly, step by step, with a tiny real example and why each part exists.

What you‚Äôre doing in one line

You send one POST request to Firestore‚Äôs :runQuery endpoint.
Inside the request body, you describe what to search (collection + filters).
Firestore replies with the matching documents.

You are not inserting anything; you‚Äôre asking Firestore to run a search.

The full journey (simple story)

You prepare inputs

formattedDate ‚Üí e.g., "2025-08-30"

userUid ‚Üí e.g., "abc123"

You build the URL

final url = Uri.parse(
  '${Apiservice.firestoreBaseUrl}:runQuery?key=${Apiservice.apiKey}'
);


firestoreBaseUrl looks like
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents

:runQuery means ‚Äúplease run the query I‚Äôll send in the body.‚Äù

apiKey authenticates your request (kept on server side ideally).

Why used? Firestore needs the API key and the special :runQuery path to accept complex queries.

You build the request body (the actual query)
Here‚Äôs your Dart map annotated:

final singleDayQueryBody = {
  "structuredQuery": { // Tell Firestore we‚Äôre sending a structured (typed) query
    "from": [
      {"collectionId": "tasks"} // Look inside the 'tasks' collection
    ],
    "where": { // Apply filters (conditions)
      "compositeFilter": { // Multiple filters combined together
        "op": "AND",       // Join filters with AND (both must be true)
        "filters": [
          { // Filter #1
            "fieldFilter": {
              "field": {"fieldPath": "date"},     // Which field?
              "op": "EQUAL",                      // Comparison operator
              "value": {"stringValue": formattedDate} // The value (typed!)
            }
          },
          { // Filter #2
            "fieldFilter": {
              "field": {"fieldPath": "userId"},   // Which field?
              "op": "EQUAL",                      // Comparison operator
              "value": {"stringValue": userUid}   // The value (typed!)
            }
          }
        ]
      }
    }
  }
};


Why each part is used?

structuredQuery ‚Üí Firestore‚Äôs format for describing searches.

from.collectionId ‚Üí tells which collection to search (tasks).

where.compositeFilter ‚Üí lets you combine multiple conditions.

op: "AND" ‚Üí require both conditions to match.

filters[] ‚Üí the list of conditions.

fieldFilter.field.fieldPath ‚Üí which field in your doc (e.g., date).

fieldFilter.op: "EQUAL" ‚Üí match exact value.

value.stringValue ‚Üí Firestore requires typed values; here the field is a string. (Other examples: integerValue, booleanValue, timestampValue.)

üëâ Important: Your app must match the field types you stored in Firestore.
If date was stored as a string ("2025-08-30"), query it as stringValue.
If it was a timestamp, you‚Äôd need timestampValue and a different format.

You send the HTTP request

await http.post(
  url,
  headers: {"Content-Type": "application/json"},
  body: json.encode(singleDayQueryBody),
);


Why used?

POST is required because you‚Äôre sending a query description in the body.

application/json tells the server you‚Äôre sending JSON.

Firestore runs your query and replies
The response is an array; each item looks like:

{
  "document": {
    "name": "projects/PROJ/databases/(default)/documents/tasks/abcd1234",
    "fields": {
      "title": {"stringValue": "Buy Groceries"},
      "description": {"stringValue": "Milk and Eggs"},
      "category": {"stringValue": "shopping"},
      "date": {"stringValue": "2025-08-30"},
      "time": {"stringValue": "10:00 AM"},
      "userId": {"stringValue": "abc123"}
    },
    "createTime": "2025-08-28T10:30:15.123456Z",
    "updateTime": "2025-08-28T10:30:15.123456Z"
  },
  "readTime": "2025-08-28T10:30:15.123456Z"
}


Why shaped like this?

Firestore always returns the document path in name.

Your actual data is in fields, with typed values.

Times are metadata; you usually don‚Äôt show them.

You parse it into your app‚Äôs list

final List data = json.decode(response.body);
task.clear();

for (var item in data) {
  if (item.containsKey('document')) {
    final doc = item['document'];
    final taskId = doc['name'].split('/').last;   // "abcd1234"
    task.add({'id': taskId, 'fields': doc['fields']});
  }
}


Why used?

You need a clean list like [{id: "...", fields: {...}}, ...] to show in UI.

split('/').last extracts the actual document ID.

You show it on screen

If still fetching ‚Üí show spinner.

If empty ‚Üí show ‚Äúno tasks‚Äù.

Else ‚Üí build ListView cards using fields['title']['stringValue'], etc.

Tiny real example (with filled values)
What you send (body)
{
  "structuredQuery": {
    "from": [{"collectionId": "tasks"}],
    "where": {
      "compositeFilter": {
        "op": "AND",
        "filters": [
          {
            "fieldFilter": {
              "field": {"fieldPath": "date"},
              "op": "EQUAL",
              "value": {"stringValue": "2025-08-30"}
            }
          },
          {
            "fieldFilter": {
              "field": {"fieldPath": "userId"},
              "op": "EQUAL",
              "value": {"stringValue": "abc123"}
            }
          }
        ]
      }
    }
  }
}

Why this works

You asked: ‚ÄúFind tasks for this user on this date.‚Äù

Firestore understands it because you used its structuredQuery format with typed values.

Quick ‚Äúwhen to use what‚Äù

GET ‚Üí when you know the exact document path (e.g., /tasks/abcd1234).

POST :runQuery ‚Üí when you need to search with filters (date, userId, etc.).

Common pitfalls (so you don‚Äôt get stuck)

‚ùå date stored as timestamp but queried as stringValue.
‚úÖ Either store as string consistently, or query as timestampValue.

‚ùå Wrong date format (dd-MM-yyyy).
‚úÖ Use the same format you saved (you‚Äôre using "yyyy-MM-dd").

‚ùå Missing header Content-Type: application/json.
‚úÖ Always include it.

‚ùå userUid is null (not saved in SharedPreferences yet).
‚úÖ Ensure you set it after login.

If you want, I can rewrite your fetchTasksFromFirebase with extra comments inline (so future-you immediately knows what each line does).



  Future<void> _showTimePickerAndScheduleNotification() async {
    // Show a time picker for the user to select a time
    final selectedTime = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.now(), // The clock will start at the current time
    );

    // If the user didn't cancel the time picker
    if (selectedTime != null) {
      // Get the current date and combine it with the selected time
      final now = DateTime.now();
      final scheduledDateTime = DateTime(
        now.year,
        now.month,
        now.day,
        selectedTime.hour,
        selectedTime.minute,
      );

      // Now, we check if the selected time is in the future.
      // If it's in the past, it won't work, so we need to add a day.
      final finalScheduledTime = scheduledDateTime.isAfter(now)
          ? scheduledDateTime
          : scheduledDateTime.add(const Duration(days: 1));

      // Finally, call the new method from your NotificationService
      NotificationService().scheduleNotificationAtTime(
        id: 1, // You can use a unique ID for each notification
        title: 'Task Reminder',
        body: 'Your task is due now!',
        scheduledTime: finalScheduledTime,
      );

      // Show a message to the user so they know it worked
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          elevation: 0,
          behavior: SnackBarBehavior.floating,
          backgroundColor: Colors.transparent,
          content: AwesomeSnackbarContent(
            title: 'Success!',
            message: 'Notification scheduled for ${finalScheduledTime.toString().split('.')[0]}',
            contentType: ContentType.success,
          ),
        ),
      );
    }
  }


     onTap: () async {
                await Navigator.push(
                  context,
                  PageRouteBuilder(
                    pageBuilder:
                        (context, animation, secondaryAnimation) =>
                            const Progressscreen(),
                    transitionsBuilder: (
                      context,
                      animation,
                      secondaryAnimation,
                      child,
                    ) {
                      return FadeTransition(opacity: animation, child: child);
                    },
                  ),
                );
              },



              // In NewTask.dart
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:day_night_time_picker/day_night_time_picker.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:tickdone/Services/Provider/date_provider.dart';
import 'package:tickdone/Services/Provider/task_provider.dart';
import 'package:tickdone/Services/Task/Newtaskservice.dart';
import 'package:intl/intl.dart';
import 'package:tickdone/Services/Notification/notification_service.dart';

class Newtask extends StatefulWidget {
  const Newtask({super.key});

  @override
  State<Newtask> createState() => _NewtaskState();
}

class _NewtaskState extends State<Newtask> {
  final taskkey = GlobalKey<FormState>();

  final TextEditingController titlecontroller = TextEditingController();
  final TextEditingController descriptioncontroller = TextEditingController();

  // A variable to hold the selected date for a single-day task.
  DateTime? selectedDate;
  // A variable to hold the selected time. It starts as null.
  Time? selectedTime;
  // A list of booleans to track which toggle button is selected.
  // We'll keep only 'Single Day' active.
  List<bool> isSelected = [true];

  // A list of pre-defined categories.
  final List<String> category = [
    'Work',
    'Personal',
    'Shopping',
    'Health',
    'Skill',
    'Home',
  ];
  // A single string to hold the selected category.
  String? selectedCategory;

  // Simple function to format a DateTime object into "day-month-year".
  String formatDate(DateTime date) {
    return "${date.day}-${date.month}-${date.year}";
  }

  // Simple function to format a Time object into 12-hour format with AM/PM.
  String formatTime(Time time) {
    final hour = time.hourOfPeriod == 0 ? 12 : time.hourOfPeriod;
    final period = time.period == DayPeriod.am ? "AM" : "PM";
    return "$hour:${time.minute.toString().padLeft(2, '0')} $period";
  }

  // A helper function to check if the selected date is today.
  bool get isToday {
    if (selectedDate == null) {
      return false;
    }
    final now = DateTime.now();
    return selectedDate!.year == now.year &&
        selectedDate!.month == now.month &&
        selectedDate!.day == now.day;
  }

  void scheduleTaskNotification(String title, DateTime scheduledDateTime) {
    NotificationService().scheduleNotificationAtTime(
      id: title.hashCode, // A simple unique ID for the task
      title: 'Task Reminder:$title ',
      body: 'Lets Do it !!',
      scheduledTime: scheduledDateTime,
    );
  }

  // Shows the single date picker pop-up.
  void presentDatePicker() {
    showDatePicker(
      context: context,
      initialDate: selectedDate ?? DateTime.now(),
      firstDate: DateTime.now(),
      lastDate: DateTime(2030),
    ).then((pickedDate) {
      if (pickedDate == null) return;

      setState(() {
        selectedDate = pickedDate;
      });
    });
  }

  late final double padding = 15.w;
  late final double titleIconSize = 28.sp;
  late final double buttonHeight = 50.h;
  late final double buttonWidth = 0.80.sw;
  late final double textFieldVerticalSpace = 10.h;
  late final double verticalPadding = 12.h;
  late final double horizontalPadding = 20.w;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          onPressed: () {
            Navigator.pop(context);
          },
          icon: Icon(Icons.close, color: Colors.white, size: titleIconSize),
        ),
        backgroundColor: const Color(0xFF1C0E6F),
        title: Text(
          'Add Task',
          style: TextStyle(
            color: Colors.white,
            fontFamily: 'Poppins',
            fontSize: 20.sp,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
      backgroundColor: Colors.black,
      body: SafeArea(
        child: SingleChildScrollView(
          child: Form(
            key: taskkey,
            child: Padding(
              padding: EdgeInsets.all(padding),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Center(
                    child: ElevatedButton.icon(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF1C0E6F),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.only(
                            topLeft: Radius.circular(25.r),
                            bottomRight: Radius.circular(25.r),
                          ),
                        ),

                        padding: EdgeInsets.symmetric(
                          horizontal: 16.w,
                          vertical: 12.h,
                        ),
                      ),
                      onPressed: presentDatePicker,
                      icon: Icon(Icons.calendar_today, color: Colors.white),
                      label: Text(
                        'Select Date',
                        style: TextStyle(
                          color: Colors.white,
                          fontFamily: 'Poppins',
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                  SizedBox(height: 15.h),
                  TextFormField(
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please Enter Title';
                      }
                      return null;
                    },
                    controller: titlecontroller,
                    style: TextStyle(color: Colors.white),
                    decoration: InputDecoration(
                      labelText: "Title",
                      icon: const Icon(Icons.title_rounded),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12.r),
                      ),
                    ),
                  ),
                  SizedBox(height: 10.h),
                  TextFormField(
                    controller: descriptioncontroller,
                    style: TextStyle(color: Colors.white),
                    maxLines: 3,
                    decoration: InputDecoration(
                      labelText: "Description",
                      icon: const Icon(Icons.description),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12.r),
                      ),
                    ),
                  ),
                  SizedBox(height: textFieldVerticalSpace),
                  Text(
                    'Select Category',
                    style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w900,
                      fontSize: 15.sp,
                      fontFamily: 'Poppins',
                    ),
                  ),
                  SizedBox(height: 5.h),
                  Wrap(
                    spacing: 8.w,
                    runSpacing: 6.h,
                    children: List.generate(category.length, (index) {
                      final String current = category[index];
                      final bool isSelected = selectedCategory == current;

                      return ChoiceChip(
                        label: Text(current),
                        selected: isSelected,
                        selectedColor: const Color(0xFF1C0E6F),
                        backgroundColor: Colors.black87,
                        labelStyle: TextStyle(
                          color: Colors.white,
                          fontFamily: 'Poppins',
                        ),
                        onSelected: (bool value) {
                          setState(() {
                            if (value) {
                              selectedCategory = current;
                            } else {
                              selectedCategory = null;
                            }
                          });
                        },
                      );
                    }),
                  ),
                  SizedBox(height: textFieldVerticalSpace),
                  if (selectedDate != null)
                    Center(
                      child: Text(
                        "Selected Date: ${formatDate(selectedDate!)}",
                        style: const TextStyle(
                          fontFamily: 'Poppins',
                          color: Colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),

                  SizedBox(height: textFieldVerticalSpace),
                  ElevatedButton.icon(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF1C0E6F),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12.r),
                      ),
                      padding: EdgeInsets.symmetric(
                        vertical: verticalPadding,
                        horizontal: horizontalPadding,
                      ),
                    ),
                    onPressed: () {
                      FocusManager.instance.primaryFocus?.unfocus();
                      Navigator.of(context).push(
                        showPicker(
                          context: context,
                          value:
                              selectedTime ??
                              Time(
                                hour: DateTime.now().hour,
                                minute: DateTime.now().minute,
                              ),
                          onChange: (newTime) {
                            setState(() {
                              selectedTime = newTime;
                            });
                          },
                          iosStylePicker: true,
                          is24HrFormat: false,
                        ),
                      );
                    },
                    icon: const Icon(Icons.access_time, color: Colors.white),
                    label: Text(
                      "Pick Time (Optional)",
                      style: TextStyle(
                        fontFamily: 'Poppins',
                        fontWeight: FontWeight.bold,
                        fontSize: 15.sp,
                        color: Colors.white,
                      ),
                    ),
                  ),

                  // Show selected time ONLY after the user has picked it.
                  if (selectedTime != null)
                    Padding(
                      padding: EdgeInsets.only(top: 8.h),
                      child: Center(
                        child: Text(
                          "Selected Time: ${formatTime(selectedTime!)}",
                          style: const TextStyle(
                            fontFamily: 'Poppins',
                            fontSize: 14,
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),

                  SizedBox(height: 20.h),

                  Center(
                    child: SizedBox(
                      height: buttonHeight,
                      width: buttonWidth,
                      child: ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF1C0E6F),
                        ),
                        onPressed: () async {
                          final prefs = await SharedPreferences.getInstance();
                          final userUid = prefs.getString('userUID');
                          // 1. Check if the form is valid.
                          if (userUid != null) {
                            if (taskkey.currentState?.validate() ?? false) {
                              // 2. If the form is valid, then proceed with creating and saving the task.
                              final taskData = {
                                'title': {'stringValue': titlecontroller.text},
                                'description': {
                                  'stringValue': descriptioncontroller.text,
                                },
                                'category': {
                                  'stringValue': selectedCategory ?? '',
                                },
                                'time': {
                                  'stringValue':
                                      selectedTime != null
                                          ? selectedTime!.format(context)
                                          : '',
                                },
                                'userId': {'stringValue': userUid},
                              };

                              // 3. Conditionally add a single date based on user selection.
                              if (selectedDate != null) {
                                taskData['date'] = {
                                  'stringValue': DateFormat(
                                    'yyyy-MM-dd',
                                  ).format(selectedDate!),
                                };
                              }

                              // 4. Call the service to save the task.
                              final taskService = Addnewtaskservice();
                              await taskService.addtasktofirebase(
                                taskData,
                                context,
                                userUid,
                              );
                              // Get the TaskProvider instance
                              final taskProvider = Provider.of<TaskProvider>(
                                context,
                                listen: false,
                              );

                              // Get the DateProvider to know which date's tasks to refresh
                              final dateProvider = Provider.of<DateProvider>(
                                context,
                                listen: false,
                              );
                              if (selectedDate != null &&
                                  selectedTime != null) {
                                final now = DateTime.now();
                                final scheduledDateTime = DateTime(
                                  selectedDate!.year,
                                  selectedDate!.month,
                                  selectedDate!.day,
                                  selectedTime!.hour,
                                  selectedTime!.minute,
                                );

                                // Check if the scheduled time is in the past and adjust it if needed.
                                final finalScheduledTime =
                                    scheduledDateTime.isAfter(now)
                                        ? scheduledDateTime
                                        : scheduledDateTime.add(
                                          const Duration(days: 1),
                                        );

                                // Call the new method to schedule the notification.
                                scheduleTaskNotification(
                                  titlecontroller.text,
                                  finalScheduledTime,
                                );
                              }
                              await taskProvider.fetchTasksFromFirebase(
                                dateProvider.selectedDate,
                              );
                              Navigator.pop(context);
                            }
                          }
                        },
                        child: Text(
                          'Save Task',
                          style: TextStyle(
                            color: Colors.white,
                            fontFamily: 'Poppins',
                            fontWeight: FontWeight.bold,
                            fontSize: 15.sp,
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
