Launching lib\main.dart on SM A528B in debug mode...
e: Daemon compilation failed: Could not connect to Kotlin compile daemon
java.lang.RuntimeException: Could not connect to Kotlin compile daemon
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemon(GradleKotlinCompilerWork.kt:204)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemonOrFallbackImpl(GradleKotlinCompilerWork.kt:161)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.run(GradleKotlinCompilerWork.kt:132)
	at org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction.execute(GradleCompilerRunnerWithWorkers.kt:76)
	at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:63)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:66)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:62)
	at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:100)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.lambda$execute$0(NoIsolationWorkerFactory.java:62)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:44)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:41)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:209)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)
	at org.gradle.workers.internal.AbstractWorker.executeWrappedInBuildOperation(AbstractWorker.java:41)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.execute(NoIsolationWorkerFactory.java:59)
	at org.gradle.workers.internal.DefaultWorkerExecutor.lambda$submitWork$0(DefaultWorkerExecutor.java:174)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runExecution(DefaultConditionalExecutionQueue.java:194)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.access$700(DefaultConditionalExecutionQueue.java:127)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner$1.run(DefaultConditionalExecutionQueue.java:169)
	at org.gradle.internal.Factories$1.create(Factories.java:31)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:263)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:127)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:132)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runBatch(DefaultConditionalExecutionQueue.java:164)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.run(DefaultConditionalExecutionQueue.java:133)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:48)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.base/java.lang.Thread.run(Unknown Source)

Errors were stored into D:\Mak big\Mini project\TickDone\tickdone\android\.gradle\kotlin\errors\errors-1757921860073.log
√ Built build\app\outputs\flutter-apk\app-debug.apk
I/flutter (21615): [IMPORTANT:flutter/shell/platform/android/android_context_vk_impeller.cc(60)] Using the Impeller rendering backend (Vulkan).

======================================================================================

Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
warning: [options] source value 8 is obsolete and will be removed in a future release
warning: [options] target value 8 is obsolete and will be removed in a future release
warning: [options] To suppress warnings about obsolete options, use -Xlint:-options.
3 warnings
e: Daemon compilation failed: Could not connect to Kotlin compile daemon
java.lang.RuntimeException: Could not connect to Kotlin compile daemon
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemon(GradleKotlinCompilerWork.kt:204)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.compileWithDaemonOrFallbackImpl(GradleKotlinCompilerWork.kt:161)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.run(GradleKotlinCompilerWork.kt:132)
	at org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction.execute(GradleCompilerRunnerWithWorkers.kt:76)
	at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:63)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:66)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:62)
	at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:100)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.lambda$execute$0(NoIsolationWorkerFactory.java:62)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:44)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:41)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:209)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)
	at org.gradle.workers.internal.AbstractWorker.executeWrappedInBuildOperation(AbstractWorker.java:41)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.execute(NoIsolationWorkerFactory.java:59)
	at org.gradle.workers.internal.DefaultWorkerExecutor.lambda$submitWork$0(DefaultWorkerExecutor.java:174)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runExecution(DefaultConditionalExecutionQueue.java:194)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.access$700(DefaultConditionalExecutionQueue.java:127)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner$1.run(DefaultConditionalExecutionQueue.java:169)
	at org.gradle.internal.Factories$1.create(Factories.java:31)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:263)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:127)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:132)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runBatch(DefaultConditionalExecutionQueue.java:164)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.run(DefaultConditionalExecutionQueue.java:133)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:48)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.base/java.lang.Thread.run(Unknown Source)

exception: c:\Users\HP\AppData\Local\Pub\Cache\hosted\pub.dev\shared_preferences_android-2.4.10\android\src\main\kotlin\io\flutter\plugins\sharedpreferences\SharedPreferencesPlugin.kt:451:52: warning: unnecessary non-null assertion (!!) on a non-null receiver of type String
exception:       if (value!!.startsWith(LIST_PREFIX) && !value!!.startsWith(JSON_LIST_PREFIX)) {
exception:            

========================================================

Got you, Ayush! Let’s unpack that whole :runQuery thing slowly, step by step, with a tiny real example and why each part exists.

What you’re doing in one line

You send one POST request to Firestore’s :runQuery endpoint.
Inside the request body, you describe what to search (collection + filters).
Firestore replies with the matching documents.

You are not inserting anything; you’re asking Firestore to run a search.

The full journey (simple story)

You prepare inputs

formattedDate → e.g., "2025-08-30"

userUid → e.g., "abc123"

You build the URL

final url = Uri.parse(
  '${Apiservice.firestoreBaseUrl}:runQuery?key=${Apiservice.apiKey}'
);


firestoreBaseUrl looks like
https://firestore.googleapis.com/v1/projects/<PROJECT_ID>/databases/(default)/documents

:runQuery means “please run the query I’ll send in the body.”

apiKey authenticates your request (kept on server side ideally).

Why used? Firestore needs the API key and the special :runQuery path to accept complex queries.

You build the request body (the actual query)
Here’s your Dart map annotated:

final singleDayQueryBody = {
  "structuredQuery": { // Tell Firestore we’re sending a structured (typed) query
    "from": [
      {"collectionId": "tasks"} // Look inside the 'tasks' collection
    ],
    "where": { // Apply filters (conditions)
      "compositeFilter": { // Multiple filters combined together
        "op": "AND",       // Join filters with AND (both must be true)
        "filters": [
          { // Filter #1
            "fieldFilter": {
              "field": {"fieldPath": "date"},     // Which field?
              "op": "EQUAL",                      // Comparison operator
              "value": {"stringValue": formattedDate} // The value (typed!)
            }
          },
          { // Filter #2
            "fieldFilter": {
              "field": {"fieldPath": "userId"},   // Which field?
              "op": "EQUAL",                      // Comparison operator
              "value": {"stringValue": userUid}   // The value (typed!)
            }
          }
        ]
      }
    }
  }
};


Why each part is used?

structuredQuery → Firestore’s format for describing searches.

from.collectionId → tells which collection to search (tasks).

where.compositeFilter → lets you combine multiple conditions.

op: "AND" → require both conditions to match.

filters[] → the list of conditions.

fieldFilter.field.fieldPath → which field in your doc (e.g., date).

fieldFilter.op: "EQUAL" → match exact value.

value.stringValue → Firestore requires typed values; here the field is a string. (Other examples: integerValue, booleanValue, timestampValue.)

👉 Important: Your app must match the field types you stored in Firestore.
If date was stored as a string ("2025-08-30"), query it as stringValue.
If it was a timestamp, you’d need timestampValue and a different format.

You send the HTTP request

await http.post(
  url,
  headers: {"Content-Type": "application/json"},
  body: json.encode(singleDayQueryBody),
);


Why used?

POST is required because you’re sending a query description in the body.

application/json tells the server you’re sending JSON.

Firestore runs your query and replies
The response is an array; each item looks like:

{
  "document": {
    "name": "projects/PROJ/databases/(default)/documents/tasks/abcd1234",
    "fields": {
      "title": {"stringValue": "Buy Groceries"},
      "description": {"stringValue": "Milk and Eggs"},
      "category": {"stringValue": "shopping"},
      "date": {"stringValue": "2025-08-30"},
      "time": {"stringValue": "10:00 AM"},
      "userId": {"stringValue": "abc123"}
    },
    "createTime": "2025-08-28T10:30:15.123456Z",
    "updateTime": "2025-08-28T10:30:15.123456Z"
  },
  "readTime": "2025-08-28T10:30:15.123456Z"
}


Why shaped like this?

Firestore always returns the document path in name.

Your actual data is in fields, with typed values.

Times are metadata; you usually don’t show them.

You parse it into your app’s list

final List data = json.decode(response.body);
task.clear();

for (var item in data) {
  if (item.containsKey('document')) {
    final doc = item['document'];
    final taskId = doc['name'].split('/').last;   // "abcd1234"
    task.add({'id': taskId, 'fields': doc['fields']});
  }
}


Why used?

You need a clean list like [{id: "...", fields: {...}}, ...] to show in UI.

split('/').last extracts the actual document ID.

You show it on screen

If still fetching → show spinner.

If empty → show “no tasks”.

Else → build ListView cards using fields['title']['stringValue'], etc.

Tiny real example (with filled values)
What you send (body)
{
  "structuredQuery": {
    "from": [{"collectionId": "tasks"}],
    "where": {
      "compositeFilter": {
        "op": "AND",
        "filters": [
          {
            "fieldFilter": {
              "field": {"fieldPath": "date"},
              "op": "EQUAL",
              "value": {"stringValue": "2025-08-30"}
            }
          },
          {
            "fieldFilter": {
              "field": {"fieldPath": "userId"},
              "op": "EQUAL",
              "value": {"stringValue": "abc123"}
            }
          }
        ]
      }
    }
  }
}

Why this works

You asked: “Find tasks for this user on this date.”

Firestore understands it because you used its structuredQuery format with typed values.

Quick “when to use what”

GET → when you know the exact document path (e.g., /tasks/abcd1234).

POST :runQuery → when you need to search with filters (date, userId, etc.).

Common pitfalls (so you don’t get stuck)

❌ date stored as timestamp but queried as stringValue.
✅ Either store as string consistently, or query as timestampValue.

❌ Wrong date format (dd-MM-yyyy).
✅ Use the same format you saved (you’re using "yyyy-MM-dd").

❌ Missing header Content-Type: application/json.
✅ Always include it.

❌ userUid is null (not saved in SharedPreferences yet).
✅ Ensure you set it after login.

If you want, I can rewrite your fetchTasksFromFirebase with extra comments inline (so future-you immediately knows what each line does).